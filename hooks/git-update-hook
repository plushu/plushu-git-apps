#!/usr/bin/env bash
set -eo pipefail; [[ -n "$PLUSHU_TRACE" ]] && set -x

# We expect GIT_DIR to be defined in the environment, which is why none of
# these commands specify the Git repository to operate on.

app=$PLUSHU_REPO_NAME

# If the master branch is being updated
if [[ "$1" == "refs/heads/master" ]]; then

  if [[ -f "$PLUSHU_ROOT/apps/$app/receive.rc" ]]; then
    source "$PLUSHU_ROOT/apps/$app/receive.rc"

    # Echo all commands if PLUSHU_TRACE was set in receive.rc,
    # and stop echoing them if it was unset
    [[ -n "$PLUSHU_TRACE" ]] && set -x || set +x
  fi

  # Build, release, and deploy the new code before accepting the update

  # If this commit doesn't use submodules
  if [[ -z "$(git ls-tree "$3" .gitmodules)" ]]; then
    # Building an untarred git-archive will suffice
    git archive "$3" | "$PLUSHU_ROOT/lib/plushook" -i build-app-tar "$app"
  # If this commit uses submodules
  else
    # Save the original Git repo
    GIT_SRC=$GIT_DIR

    # Create a temporary working tree to clone into
    TMP_WORK_DIR=$(mktemp -d)
    chmod 755 "$TMP_WORK_DIR"

    # Within a silenced subshell
    (
      # Unset the variables pointing to the original Git repo
      unset GIT_DIR GIT_WORK_TREE

      # Create a linked clone of the source
      git clone "$GIT_SRC" "$TMP_WORK_DIR"

      # Enter the clone
      cd "$TMP_WORK_DIR"

      # Suppress detached head warnings (since we're still listening for
      # stderr output)
      git config advice.detachedHead false

      # check out the commit currently being pushed, as a detached head
      git checkout "$3"

      # Update submodules
      git submodule update --init --recursive

      # Remove git data
      find -name .git -prune -exec rm -rf {} \;
    ) > /dev/null

    # Build with the temp directory
    "$PLUSHU_ROOT/lib/plushook" build-app-dir "$app" "$TMP_WORK_DIR"

    # Remove the temp directory
    rm -rf "$TMP_WORK_DIR"
  fi
  "$PLUSHU_ROOT/lib/plushook" release-app "$app"
  "$PLUSHU_ROOT/lib/plushook" deploy-app "$app"
fi
